import os
import sys

def read_sql(result: dict, sql_file, directory_path):
    # Получите относительный путь относительно directory_path
    relative_path = os.path.relpath(sql_file, directory_path)
    file_name = os.path.basename(sql_file)
    file_name_without_extension, _ = os.path.splitext(file_name)
    if file_name_without_extension in result.keys():
        raise ValueError(f"Дублируется имя файла. Первый путь:{result['path']}, второй путь:{relative_path}")
    with open(sql_file, 'r') as file:
        content = file.read()
    result[file_name_without_extension] = {
        'path': directory_path + '/' + relative_path,
        'content': content
    }
def read_sqls(directory_path):
    result = {}
    os_paths = []
    for root, dir, files in os.walk(directory_path):
        for file in files:
            if file.endswith(".sql"):
                os_paths.append(os.path.join(root, file))
    os_paths.sort()
    for os_path in os_paths:
        read_sql(result, os_path, directory_path)
    return result


def place_begin_namespace(content, namespace):
    return content + '\nnamespace ' + namespace + '{\n\n'

def place_end_namespace(content, namespace):
    return content + '}\n'

def place_extern_sql_query(result_hpp: str, name: str, path: str):
    add = '//Generated from: ' + path + '\nextern const userver::storages::postgres::Query ' + name + ';\n\n'
    return result_hpp + add

def place_impl_sql_query(result_cpp: str, name: str, path: str, content: str):
    add = '//Generated from: ' + path + '\nconst userver::storages::postgres::Query ' + name + ' = {\n'
    add = add + 'R"-(\n'
    add = add + content
    add = add + ')-",\n'
    add = add + '\tuserver::storages::postgres::Query::Name("' + name + '"),\n'
    add = add + '\tuserver::storages::postgres::Query::LogMode::kFull\n'
    add = add + '};\n\n'
    return result_cpp + add

def prepare_result_contents(sqls: dict, namespace, name_result):
    result_hpp = '''#pragma once
    
/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */
    
#include <userver/storages/postgres/query.hpp>
'''
    result_cpp = '''
/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */
    
#include "''' + name_result + '.hpp"\n'

    result_hpp = place_begin_namespace(result_hpp, namespace)
    result_cpp = place_begin_namespace(result_cpp, namespace)
    for name, item in sqls.items():
        result_hpp = place_extern_sql_query(result_hpp, name, item['path'])
        result_cpp = place_impl_sql_query(result_cpp, name, item['path'], item['content'])
    result_hpp = place_end_namespace(result_hpp, namespace)
    result_cpp = place_end_namespace(result_cpp, namespace)
    return result_hpp, result_cpp

def main():
    if len(sys.argv) < 5:
        print('Usage: python3 generate_sql_queries.py <sql_directory> <path/to/result> <name_result> <namespace>')
        return

    sql_directory = sys.argv[1]
    path_to_result = sys.argv[2]
    name_result = sys.argv[3]
    namespace = sys.argv[4]
    sqls = read_sqls(sql_directory)
    result_hpp, result_cpp = prepare_result_contents(sqls, namespace, name_result)

    hpp_path = path_to_result + '/' + name_result + '.hpp'
    cpp_path = path_to_result + '/' + name_result + '.cpp'

    if not os.path.exists(path_to_result):
        os.makedirs(path_to_result)

    with open(hpp_path, 'w') as hpp:
        hpp.write(result_hpp)
    with open(cpp_path, 'w') as cpp:
        cpp.write(result_cpp)

if __name__ == '__main__':
    main()